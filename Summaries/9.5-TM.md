# Section 9.5: Turing Machines

## Overview

Section 9.5 provides a comprehensive treatment of Turing machines (TMs), covering their formal definition, variants, computational power, decidability theory, and undecidability results. The section establishes TMs as the foundational model for understanding what is algorithmically computable.

## 1. Basic Turing Machine Model

### 1.1 Informal Description
A Turing machine is an automaton consisting of:
- A **finite control** (the states)
- An **infinite tape** (capturing the intuition of "unlimited space")
- Initially: input on tape, head positioned at first symbol, state is q₀
- All other squares contain blanks (□)

### 1.2 Formal Definition
A TM is a 7-tuple: **(Q, Σ, Γ, δ, q₀, qₐ, qᵣ)** where:
- **Q**: finite set of states
- **Σ**: input alphabet
- **Γ**: tape alphabet (Σ ∪ {□} ⊆ Γ)
- **δ**: transition function δ(q,X) = (p,Y,D) where D ∈ {L, R}
- **q₀**: initial state
- **qₐ**: accepting state
- **qᵣ**: rejecting state

### 1.3 Configurations
A **configuration** is a string *upv* where:
- u, v ∈ Γ*
- p ∈ Q
- The head is scanning the first symbol of v
- The state is p

**Initial configuration**: q₀w where w is the input

**Yield relation**: Configuration C₁ **yields** C₂ (written C₁ → C₂) if:
- δ(qᵢ,b) = (qⱼ,c,L): then uaqᵢbv yields uqⱼacv
- δ(qᵢ,b) = (qⱼ,c,R): then uaqᵢbv yields uacqⱼv

### 1.4 Language Recognition
**L(M)** = {w ∈ Σ* | q₀w ⇒* αqₐβ}

The TM halts when it enters qₐ or qᵣ.

**Exercise**: Design a TM that recognizes palindromes.

## 2. Robustness of TM Model

Different TM variants are equivalent in computational power:
- Tape infinite in one direction vs. two directions
- Single tape vs. multiple tapes
- Different alphabets

This **robustness** demonstrates that the TM model captures a fundamental notion of computation.

## 3. Language Classes

### 3.1 Recursively Enumerable (RE) Languages
A language L is **RE** (recognizable, Turing-recognizable) if:
- There exists a TM M such that L = L(M)
- M halts in qₐ for all x ∈ L
- M does not accept x ∉ L (may loop or reject)

### 3.2 Recursive (Decidable) Languages
A language L is **recursive** (decidable, Turing-decidable) if:
- There exists a TM M that always halts
- M halts in qₐ for all x ∈ L
- M halts in qᵣ for all x ∉ L

Recursive languages correspond to **algorithmically recognizable** languages.

## 4. Nondeterministic Turing Machines

### 4.1 Definition
A **nondeterministic TM (NTM)** has a transition relation instead of function:
- δ(q,a) = {(q₁,b₁,D₁), (q₂,b₂,D₂), ..., (qₖ,bₖ,Dₖ)}
- Multiple possible moves on a given configuration

### 4.2 Equivalence Theorem
**Theorem**: If N is a nondeterministic TM, then there exists a deterministic TM D such that L(N) = L(D).

**Proof sketch**: D uses breadth-first search to explore all possible moves of N:
- Uses multiple tapes
- Maintains a sequence of configurations
- If N has degree of nondeterminism m and makes n moves before accepting, D examines approximately nm^n configurations

### 4.3 Simulation
A key concept: TMs can **simulate** other TMs. This can be done by:
- Encoding the simulated machine in the states of the simulator
- Placing the description on tape and simulating each move

## 5. Encodings

### 5.1 ASCII and Unicode
- **ASCII**: 7-bit encoding (128 symbols), extended to 8-bit (256 symbols)
- **UTF-8**: Variable-width encoding for Unicode (1-4 bytes)
- **Base64**: Radix-64 encoding using 64 symbols

### 5.2 Encoding Automata
Example encoding of DFA B = (Q,Σ,δ,q₀,F):
⟨B⟩ := 0^n 1 0^{l₁⁰}1 0^{l₁¹}1 ... 0^{lₙ⁰}1 0^{lₙ¹}1 0^{i₁}1...1 0^{iₖ}

Pairs can be encoded as ⟨B,w⟩ := ⟨B⟩11w (using "11" as separator)

### 5.3 Encoding Turing Machines
TMs can be encoded as binary strings. Example partial encoding:
- 00 11 0 1 00 1 00 1 0 1 0 11 ...
- (2 states, transition δ(q₁,1)=(q₂,0,→), ...)

### 5.4 Well-Formed Strings (WFS)
A string x ∈ {0,1}* is a **WFS** if there exists a TM M and string w such that x = ⟨M,w⟩.

The language of WFS is **decidable**.

## 6. Decidability Results

### 6.1 Decidable Languages
Regular and context-free languages are decidable.

**Examples of decidable languages**:
- A_DFA = {⟨B,w⟩ : B is a DFA that accepts w}
- A_NFA = {⟨B,w⟩ : B is an NFA that accepts w}
- A_REX = {⟨R,w⟩ : R is a regex that accepts w}
- E_DFA = {⟨A⟩ : L(A) = ∅}
- EQ_DFA = {⟨A,B⟩ : L(A) = L(B)}
- E_CFG = {⟨G⟩ : L(G) = ∅}

### 6.2 Closure Properties

**Theorem**: If L is decidable, so is its complement L̄.

**Proof**: Swap accept/reject states in the decider.

**Theorem**: If both L and L̄ are RE, then L is decidable.

**Proof**: Run both recognizers in parallel; one must accept.

## 7. Church-Turing Thesis

> *The intuitive notion of algorithm is captured by the formal definition of a TM.*

This is a **thesis** (not a theorem) because "algorithm" is an intuitive concept. It proposes that TMs formalize our intuitive understanding of computation.

### 7.1 Universal Turing Machine (UTM)

The **universal language**: A_TM = {⟨M,w⟩ : M is a TM and M accepts w}

The **Universal Turing Machine U**:
- On input ⟨M,w⟩, checks if it's a WFS
- If yes, simulates M on w
- Accepts if M accepts

U **recognizes** A_TM but does **not decide** it.

**Historical note**: Turing's UTM was revolutionary—proposing "one machine to solve all problems" contradicted the engineering principle of "one machine for one problem."

**Records**:
- 1960s: Marvin Minsky proposed 7-state, 2-symbol UTM
- 2008: Alex Smith proposed 2-state, 3-symbol UTM

## 8. Undecidability

### 8.1 Main Undecidability Result

**Theorem**: A_TM is undecidable.

**Proof** (by contradiction using diagonalization):
- Assume H decides A_TM
- Construct D where D(⟨M⟩) accepts iff H(⟨M,⟨M⟩⟩) rejects
- Then D(⟨D⟩) accepts iff it rejects—contradiction!

**Practical consequence**: No debugger can implement a "halting feature" that always correctly determines if a program will halt.

**Important note**: The theorem doesn't prevent a TM from correctly answering for *some* inputs—it only says no algorithm works for *all* inputs.

### 8.2 Busy Beaver Function

Σ(n,m) = maximum number of squares writable by an n-state, m-symbol TM starting on empty tape.

**Known values** (m=2):
- Σ(2) = 4
- Σ(3) = 6
- Σ(4) = 13
- Σ(5) ≥ 4098
- Σ(6) ≥ 3.5 × 10^18267

**Undecidability**: If Σ were decidable, we could decide A_TM (contradiction).

### 8.3 Complement of A_TM

**Corollary**: A̅_TM is not RE.

**Proof**: Since A_TM is RE, if A̅_TM were also RE, then A_TM would be decidable (contradiction).

## 9. Enumerators

### 9.1 Definition
An **enumerator** is a TM with:
- Work tape (initially empty)
- Output tape (write-only, never moves left)
- Writes strings separated by # symbols

A language is **enumerable** if there exists an enumerator E such that L = L(E).

### 9.2 Equivalence Theorem

**Theorem**: A language is recognizable iff it is enumerable.

**Proof**:
- (⇐) If L is enumerable, build recognizer that simulates enumerator and accepts if w appears in output
- (⇒) If L is recognizable by M, build enumerator using **dovetailing**: in phase i, simulate M on first i strings for i steps each; output when M accepts

## 10. Reductions

Technique for showing undecidability by reducing known undecidable problems to new problems.

### 10.1 HALT is Undecidable

HALT = {⟨M,w⟩ : M is a TM that halts on w}

**Proof**: If H decides HALT, construct H' that decides A_TM:
- H'(⟨M,w⟩) runs H(⟨M,w⟩)
- If H accepts, H' simulates M on w and answers accordingly
- Otherwise H' rejects
- This contradicts undecidability of A_TM

### 10.2 E_TM is Undecidable

E_TM = {⟨M⟩ : L(M) = ∅}

**Proof**: If R decides E_TM, construct R' deciding A_TM:
- R'(⟨M,w⟩) constructs M_w where M_w(x) accepts iff x=w and M accepts w
- R' runs R on ⟨M_w⟩
- Contradiction

### 10.3 REGULAR_TM is Undecidable

REGULAR_TM = {⟨M⟩ : L(M) is regular}

**Proof**: If R decides REGULAR_TM, construct S deciding A_TM:
- S(⟨M,w⟩) constructs M' where M'(x) accepts if x has form 0^n1^n, or runs M on w
- L(M') is either {0^n1^n} (nonregular) or {0,1}* (regular)
- Contradiction

## 11. Rice's Theorem

### 11.1 Properties of Languages

A **property** P is a subset of {⟨M⟩ : M is a TM}.

P is **nontrivial** if:
- P ≠ ∅ and P̄ ≠ ∅
- If L(M₁) = L(M₂), then either both ⟨M₁⟩, ⟨M₂⟩ ∈ P or both ∉ P

**Rice's Theorem**: Every nontrivial property is undecidable.

This means we cannot algorithmically decide any interesting property about the language accepted by a TM.

## 12. Post's Correspondence Problem (PCP)

### 12.1 Definition

An instance of PCP consists of two equal-length lists:
- A = w₁, w₂, ..., wₖ
- B = x₁, x₂, ..., xₖ

A **solution** is a sequence i₁, i₂, ..., iₘ (m ≥ 1) such that:
w_{i₁}w_{i₂}...w_{iₘ} = x_{i₁}x_{i₂}...x_{iₘ}

**Example**:
- A = 1, 10111, 10
- B = 111, 10, 0
- Solution: i₁=2, i₂=1, i₃=1, i₄=3
  - 10111·1·1·10 = 10·111·111·0

### 12.2 Modified PCP (MPCP)

MPCP requires that the first pair in the solution must be the first pair of (A,B).

A **partial solution** i₁, i₂, ..., iᵣ means one of the following is a prefix of the other:
- w₁w_{i₁}...w_{iᵣ} or x₁x_{i₁}...x_{iᵣ}

### 12.3 Undecidability of PCP

**Strategy**: Show PCP decidable ⇒ MPCP decidable ⇒ A_TM decidable ⇒ contradiction

**Lemma 1**: If PCP is decidable, then MPCP is decidable.

**Proof**: Transform MPCP instance (A,B) to PCP instance (A',B') using new symbols * and $:
- If A = w₁, w₂, ..., wₖ, then A' = *w̄₁*, w̄₁*, w̄₂*, ..., w̄ₖ*, $
- If B = x₁, x₂, ..., xₖ, then B' = *x̄₁, *x̄₁, *x̄₂, ..., *x̄ₖ, *$
- Where w̄ inserts * between each symbol

**Lemma 2**: If MPCP is decidable, then A_TM is decidable.

**Proof**: Given (M,w), construct MPCP instance (A,B) that simulates M on w:
- Partial solutions represent computation: #α₁#α₂#α₃#...
- B list is "one configuration ahead" of A list
- A catches up only when M accepts
- Detailed construction includes:
  1. First pair: (A: #, B: #q₀w#)
  2. Copying pairs for tape symbols
  3. Transition simulation pairs
  4. Accepting configuration catch-up pairs
  5. Final pair to complete matching

The text provides a detailed worked example with a specific TM.

### 12.4 Significance

PCP provides a characterization of undecidable languages **without mention of Turing machines**. This shows undecidability is not a quirk of TMs but an immutable property of certain languages—analogous to how Myhill-Nerode characterizes regular languages model-independently.

## 13. Undecidable Properties of CFLs

Using PCP undecidability, we can prove many CFL properties are undecidable.

### 13.1 Construction

Given PCP instance (A,B) where A = w₁,...,wₖ and B = x₁,...,xₖ, construct CFGs:
- G_A: A → w₁Aa₁ | w₂Aa₂ | ... | wₖAaₖ | w₁a₁ | ... | wₖaₖ
- G_B: B → x₁Ba₁ | x₂Ba₂ | ... | xₖBaₖ | x₁a₁ | ... | xₖaₖ

Where a₁,...,aₖ are new symbols. L_A and L_B consist of strings:
- w_{i₁}w_{i₂}...w_{iₘ}a_{iₘ}...a_{i₂}a_{i₁}
- x_{i₁}x_{i₂}...x_{iₘ}a_{iₘ}...a_{i₂}a_{i₁}

### 13.2 Undecidable Problems

**Theorem**: CFG ambiguity is undecidable.

**Proof**: Construct G_AB with rule S → A | B. Then G_AB is ambiguous iff (A,B) has a solution.

**Theorem**: The following are undecidable for CFGs G₁, G₂ and regex R:
1. L(G₁) ∩ L(G₂) = ∅?
2. L(G₁) = L(G₂)?
3. L(G₁) = L(R)?
4. L(G₁) = T*?
5. L(G₁) ⊆ L(G₂)?
6. L(R) ⊆ L(G₂)?

**Key insight**: L̄_A is also context-free (proven via PDA construction), enabling reductions.

## Key Takeaways

1. **TMs formalize computation**: The Church-Turing thesis proposes TMs capture our intuitive notion of algorithm
2. **Decidability hierarchy**: Decidable ⊂ RE ⊂ All languages
3. **Universal computation**: The UTM can simulate any TM—the foundation of general-purpose computers
4. **Fundamental limits**: Some problems are provably undecidable (e.g., A_TM, HALT, E_TM)
5. **Rice's Theorem**: All nontrivial semantic properties of TM languages are undecidable
6. **Reduction technique**: Powerful method for proving undecidability
7. **PCP significance**: Undecidability exists independent of computation models
8. **Practical impact**: Debuggers cannot implement perfect halting detection, compiler optimizations have limits

## Figures Referenced

- **Figure 47**: Initial contents of TM tape (Manuscript/soltys_alg.tex:14496-14511)
- **Figure 48**: Definition of nondeterministic TM N with computation tree (Manuscript/soltys_alg.tex:14612-14630)

## Related Sections

- Section 8.3: Nondeterministic Finite Automata (NFAs) - foundational concept for nondeterminism
- Section 8.6: Myhill-Nerode Theorem - model-independent characterization of regular languages
- Earlier sections on DFAs, NFAs, PDAs - lead up to TM as most powerful automaton

## Historical Context

- **Alan Turing**: Proposed the TM model and the revolutionary concept of a universal machine
- **Marvin Minsky**: 1960s AI pioneer who worked on minimal UTMs
- **Alex Smith**: 2008 record for smallest UTM (2 states, 3 symbols)
- **Emil Post**: Post's Correspondence Problem (1946)
- **Henry Rice**: Rice's Theorem (1953)

---

**Notes**: This section is fundamental to theoretical computer science, establishing the limits of computation and the foundations of complexity theory. The material builds toward understanding P vs NP and computational complexity classes covered in later sections.
