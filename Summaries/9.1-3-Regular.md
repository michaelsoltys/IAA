# Regular Languages Summary (Sections 9.1-9.3)

## Chapter Overview

Regular languages are the simplest type of formal languages, described by computers without memory (finite automata). This chapter examines different computational models that describe regular languages and their properties.

**Computational Hierarchy:**
- **Regular languages** ‚Üê Finite Automata (no memory)
- **Context-free languages** ‚Üê Push-Down Automata (stack memory) 
- **Recursive languages** ‚Üê Turing Machines (unlimited memory)

## Section 9.1: Deterministic Finite Automaton (DFA)

### Formal Definition

A **Deterministic Finite Automaton (DFA)** is a 5-tuple: **A = (Q, Œ£, Œ¥, q‚ÇÄ, F)**

Where:
- **Q**: Finite set of states
- **Œ£**: Alphabet (finite set of input symbols)
- **Œ¥: Q √ó Œ£ ‚Üí Q**: Transition function (the "program")
- **q‚ÇÄ**: Start state (initial state)
- **F ‚äÜ Q**: Set of final (accepting) states

### DFA Operation

**String Processing:**
For input string w = a‚ÇÅa‚ÇÇ...a‚Çô:
1. Start in state q‚ÇÄ
2. Apply transitions: Œ¥(q‚ÇÄ,a‚ÇÅ) = q‚ÇÅ, Œ¥(q‚ÇÅ,a‚ÇÇ) = q‚ÇÇ, ...
3. Accept if final state q‚Çô ‚àà F, reject otherwise

**Formal Acceptance:**
A accepts w if there exists sequence r‚ÇÄ,r‚ÇÅ,...,r‚Çô where:
- r‚ÇÄ = q‚ÇÄ
- Œ¥(r·µ¢, w·µ¢‚Çä‚ÇÅ) = r·µ¢‚Çä‚ÇÅ for i = 0,1,...,n-1
- r‚Çô ‚àà F

### Example: Substring "01" Recognition

**Language**: L‚ÇÄ‚ÇÅ = {w | w contains "01" as substring}

**DFA Design**: A = ({q‚ÇÄ,q‚ÇÅ,q‚ÇÇ}, {0,1}, Œ¥, q‚ÇÄ, {q‚ÇÅ})

**Transition Table:**
```
      | 0   | 1
------|-----|----
‚Üí q‚ÇÄ  | q‚ÇÇ  | q‚ÇÄ
* q‚ÇÅ  | q‚ÇÅ  | q‚ÇÅ  
  q‚ÇÇ  | q‚ÇÇ  | q‚ÇÅ
```

### Extended Transition Function

**Definition**: Œ¥ÃÇ: Q √ó Œ£* ‚Üí Q
- **Base case**: Œ¥ÃÇ(q,Œµ) = q
- **Inductive step**: Œ¥ÃÇ(q,xa) = Œ¥(Œ¥ÃÇ(q,x), a)

**Language of DFA**: L(A) = {w | Œ¥ÃÇ(q‚ÇÄ,w) ‚àà F}

### Regular Operations

Regular languages are **closed** under three fundamental operations:

1. **Union**: L ‚à™ M = {w | w ‚àà L or w ‚àà M}
2. **Concatenation**: LM = {xy | x ‚àà L and y ‚àà M}  
3. **Kleene Star**: L* = {w | w = x‚ÇÅx‚ÇÇ...x‚Çô and x·µ¢ ‚àà L}

**Key Difference**: For languages, L‚Å∫ ‚â† L* - {Œµ} in general (unlike alphabets)

### Closure Under Union (Theorem Proof)

**Construction**: For DFAs M‚ÇÅ, M‚ÇÇ, build M where:
- Q_M = Q_{M‚ÇÅ} √ó Q_{M‚ÇÇ} (Cartesian product)
- Œ¥_M((r‚ÇÅ,r‚ÇÇ), a) = (Œ¥_{M‚ÇÅ}(r‚ÇÅ,a), Œ¥_{M‚ÇÇ}(r‚ÇÇ,a))
- F_M = {(r‚ÇÅ,r‚ÇÇ) | r‚ÇÅ ‚àà F_{M‚ÇÅ} or r‚ÇÇ ‚àà F_{M‚ÇÇ}}

## Section 9.2: Nondeterministic Finite Automata (NFA)

### Key Differences from DFA

**Nondeterminism allows:**
- Multiple transitions from same state on same symbol
- Œµ-transitions (empty string transitions)
- "Branching" - being in multiple states simultaneously

**Analogy**: Fork mechanism in C programming - parallel execution paths

### Formal Definition

**NFA**: Same 5-tuple as DFA, but Œ¥ is a **transition relation**
- **Œ¥ ‚äÜ Q √ó Œ£ √ó Q**: Multiple possible transitions
- **Alternative view**: Œ¥: Q √ó Œ£ ‚Üí ùí´(Q) (power set of Q)

### Œµ-Transitions

**Œµ-closure(q)**: Set of all states reachable from q via Œµ-transitions
- q ‚àà Œµ-closure(q) (reflexive)
- If p ‚àà Œµ-closure(q) and p ‚Üí^Œµ r, then r ‚àà Œµ-closure(q)

### Extended Transition Relation for NFAs

**Definition**: Œ¥ÃÇ: Q √ó Œ£* ‚Üí ùí´(Q)
- Œ¥ÃÇ(q,Œµ) = Œµ-closure(q)
- Œ¥ÃÇ(q,wa) = ‚ãÉ·µ¢ Œµ-closure(r·µ¢) where {r‚ÇÅ,...,r‚Çò} = ‚ãÉ_p‚ààŒ¥ÃÇ(q,w) Œ¥(p,a)

### NFA Acceptance

**String w is accepted** if there exists a path to an accepting state:
- Allow Œµ-padding of input string
- Accept if any final state is reachable

### Example: nth Symbol from End

**Language**: L‚Çô = {w | nth symbol from end is 1}

**NFA advantage**: Simple n+1 state construction vs. exponential DFA requirement

### NFA-DFA Equivalence Theorem

**Theorem**: DFAs and NFAs recognize exactly the same class of languages (regular languages)

### Subset Construction (NFA ‚Üí DFA)

**Algorithm**: Given NFA N, construct equivalent DFA M:
- **Q_M = ùí´(Q_N)**: States are subsets of NFA states  
- **(q_M)‚ÇÄ = {(q_N)‚ÇÄ}**: Initial state contains NFA start state
- **F_M = {Q ‚àà ùí´(Q_N) | Q ‚à© F_N ‚â† ‚àÖ}**: Accept if any NFA final state included
- **Œ¥_M(Q,a) = ‚ãÉ_{q‚ààQ} Œµ-closure(Œ¥_N(q,a))**: Union of all possible transitions

**Cost**: Exponential blowup - |Q_M| = 2^|Q_N|

### Practical Considerations

- Many constructed DFA states may be unreachable
- Can optimize by only generating reachable states
- Some NFA families require exponential DFA size

## Section 9.3: Regular Expressions

### Motivation

Regular expressions are familiar pattern-matching tools used in:
- Text editors (VIM, grep, sed)
- Programming languages  
- Search and replace operations

**Example VIM command**: `:23,43s/\(.*\n\)\{3\}/&\r/`
Inserts blank line every third line between lines 23-43

### Formal Definition

**Regular Expression (RE)** defined by structural induction:

**Base cases**: a ‚àà Œ£, Œµ, ‚àÖ

**Inductive cases**: If E, F are REs, then so are:
- E + F (union)
- EF (concatenation)  
- (E)* (Kleene star)
- (E) (grouping)

### Semantics of Regular Expressions

- **L(a) = {a}**: Single symbol
- **L(Œµ) = {Œµ}**: Empty string
- **L(‚àÖ) = ‚àÖ**: Empty language
- **L(E+F) = L(E) ‚à™ L(F)**: Union
- **L(EF) = L(E)L(F)**: Concatenation
- **L(E*) = (L(E))**:* Kleene closure

### RE-NFA Equivalence Theorem

**Theorem**: A language is regular iff it can be expressed by some regular expression

### RE ‚Üí NFA Construction

**Structural induction** with invariants:
1. Exactly one accepting state
2. No arrows into initial state  
3. No arrows out of accepting state

**Base cases**: Simple 2-state NFAs for Œµ, ‚àÖ, a

**Inductive cases**: 
- **Union E+F**: New start state with Œµ-transitions to both subautomata
- **Concatenation EF**: Connect E's final to F's start with Œµ-transition
- **Star E***: Add Œµ-transitions for looping and bypassing

### NFA ‚Üí RE Construction

Two methods available:

#### Method 1: Dynamic Programming

**State elimination approach**:
- R^(k)·µ¢‚±º = RE for paths from q·µ¢ to q‚±º using intermediate states ‚â§ k
- **Base case**: R^(0)·µ¢‚±º includes direct transitions and self-loops
- **Recursive case**: R^(k)·µ¢‚±º = R^(k-1)·µ¢‚±º + R^(k-1)·µ¢‚Çñ(R^(k-1)‚Çñ‚Çñ)*R^(k-1)‚Çñ‚±º

#### Method 2: Generalized NFA (GNFA)

**Generalized NFA**: NFA with regular expressions as edge labels
- Simplify by eliminating states one by one
- Update edge labels with combined expressions
- Continue until only start and accept states remain

## Key Relationships and Theorems

### Fundamental Equivalences

**Regular languages are characterized by**:
- DFAs (deterministic finite automata)
- NFAs (nondeterministic finite automata)  
- Regular expressions (syntactic descriptions)

### Closure Properties

Regular languages are closed under:
- Union, concatenation, Kleene star (regular operations)
- Intersection, complement (additional closure properties)

### Computational Complexity

- **NFA ‚Üí DFA**: Exponential state blowup possible
- **RE ‚Üí NFA**: Linear in expression size
- **NFA ‚Üí RE**: Exponential expression size possible

## Practical Applications

### Text Processing
- Pattern matching in editors
- Search and replace operations
- Input validation

### Compiler Design  
- Lexical analysis (tokenization)
- Syntax highlighting
- Language recognition

### System Administration
- Log file analysis
- Configuration file processing
- Network packet filtering

## Important Exercises and Examples

### Design Problems
1. DFA for "third symbol is 0"
2. DFA for "odd positions are 1"  
3. NFA for "nth symbol from end is 1"
4. RE for strings not containing "101"

### Theoretical Problems
1. Prove closure under concatenation and star
2. Show NFA families requiring exponential DFA size
3. Convert specific automata between representations
4. Optimize subset construction for reachable states

### Applications
1. Vending machine change calculation
2. Binary number divisibility testing
3. Decimal number format recognition
4. Pattern matching in text processing

## Summary

Regular languages form the foundation of formal language theory, providing the simplest yet powerful model for string recognition. The equivalence of DFAs, NFAs, and regular expressions gives multiple perspectives on the same computational power, each with distinct advantages for different applications. Understanding these models is crucial for compiler design, text processing, and theoretical computer science.